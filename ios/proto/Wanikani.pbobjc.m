// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/wanikani.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "proto/Wanikani.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - WKWanikaniRoot

@implementation WKWanikaniRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - WKWanikaniRoot_FileDescriptor

static GPBFileDescriptor *WKWanikaniRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"proto"
                                                 objcPrefix:@"WK"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - WKMeaning

@implementation WKMeaning

@dynamic hasMeaning, meaning;
@dynamic hasIsPrimary, isPrimary;

typedef struct WKMeaning__storage_ {
  uint32_t _has_storage_[1];
  NSString *meaning;
} WKMeaning__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "meaning",
        .dataTypeSpecific.className = NULL,
        .number = WKMeaning_FieldNumber_Meaning,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WKMeaning__storage_, meaning),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isPrimary",
        .dataTypeSpecific.className = NULL,
        .number = WKMeaning_FieldNumber_IsPrimary,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WKMeaning class]
                                     rootClass:[WKWanikaniRoot class]
                                          file:WKWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WKMeaning__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WKReading

@implementation WKReading

@dynamic hasReading, reading;
@dynamic hasIsPrimary, isPrimary;
@dynamic hasType, type;

typedef struct WKReading__storage_ {
  uint32_t _has_storage_[1];
  WKReading_Type type;
  NSString *reading;
} WKReading__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "reading",
        .core.dataTypeSpecific.className = NULL,
        .core.number = WKReading_FieldNumber_Reading,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(WKReading__storage_, reading),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "isPrimary",
        .core.dataTypeSpecific.className = NULL,
        .core.number = WKReading_FieldNumber_IsPrimary,
        .core.hasIndex = 1,
        .core.offset = 2,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueEnum = WKReading_Type_Onyomi,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = WKReading_Type_EnumDescriptor,
        .core.number = WKReading_FieldNumber_Type,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(WKReading__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WKReading class]
                                     rootClass:[WKWanikaniRoot class]
                                          file:WKWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(WKReading__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum WKReading_Type

GPBEnumDescriptor *WKReading_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Onyomi\000Kunyomi\000Nanori\000";
    static const int32_t values[] = {
        WKReading_Type_Onyomi,
        WKReading_Type_Kunyomi,
        WKReading_Type_Nanori,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(WKReading_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:WKReading_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL WKReading_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case WKReading_Type_Onyomi:
    case WKReading_Type_Kunyomi:
    case WKReading_Type_Nanori:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - WKRadical

@implementation WKRadical

@dynamic hasCharacterImage, characterImage;
@dynamic hasMnemonic, mnemonic;

typedef struct WKRadical__storage_ {
  uint32_t _has_storage_[1];
  NSString *characterImage;
  NSString *mnemonic;
} WKRadical__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "characterImage",
        .dataTypeSpecific.className = NULL,
        .number = WKRadical_FieldNumber_CharacterImage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WKRadical__storage_, characterImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mnemonic",
        .dataTypeSpecific.className = NULL,
        .number = WKRadical_FieldNumber_Mnemonic,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WKRadical__storage_, mnemonic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WKRadical class]
                                     rootClass:[WKWanikaniRoot class]
                                          file:WKWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WKRadical__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WKKanji

@implementation WKKanji

@dynamic hasMeaningMnemonic, meaningMnemonic;
@dynamic hasMeaningHint, meaningHint;
@dynamic hasReadingMnemonic, readingMnemonic;
@dynamic hasReadingHint, readingHint;

typedef struct WKKanji__storage_ {
  uint32_t _has_storage_[1];
  NSString *meaningMnemonic;
  NSString *meaningHint;
  NSString *readingMnemonic;
  NSString *readingHint;
} WKKanji__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "meaningMnemonic",
        .dataTypeSpecific.className = NULL,
        .number = WKKanji_FieldNumber_MeaningMnemonic,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WKKanji__storage_, meaningMnemonic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meaningHint",
        .dataTypeSpecific.className = NULL,
        .number = WKKanji_FieldNumber_MeaningHint,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WKKanji__storage_, meaningHint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "readingMnemonic",
        .dataTypeSpecific.className = NULL,
        .number = WKKanji_FieldNumber_ReadingMnemonic,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WKKanji__storage_, readingMnemonic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "readingHint",
        .dataTypeSpecific.className = NULL,
        .number = WKKanji_FieldNumber_ReadingHint,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WKKanji__storage_, readingHint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WKKanji class]
                                     rootClass:[WKWanikaniRoot class]
                                          file:WKWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WKKanji__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WKVocabulary

@implementation WKVocabulary

@dynamic hasMeaningExplanation, meaningExplanation;
@dynamic hasReadingExplanation, readingExplanation;
@dynamic sentencesArray, sentencesArray_Count;
@dynamic partsOfSpeechArray, partsOfSpeechArray_Count;
@dynamic hasAudio, audio;

typedef struct WKVocabulary__storage_ {
  uint32_t _has_storage_[1];
  NSString *meaningExplanation;
  NSString *readingExplanation;
  NSMutableArray *sentencesArray;
  GPBEnumArray *partsOfSpeechArray;
  NSString *audio;
} WKVocabulary__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "meaningExplanation",
        .dataTypeSpecific.className = NULL,
        .number = WKVocabulary_FieldNumber_MeaningExplanation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WKVocabulary__storage_, meaningExplanation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "readingExplanation",
        .dataTypeSpecific.className = NULL,
        .number = WKVocabulary_FieldNumber_ReadingExplanation,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WKVocabulary__storage_, readingExplanation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sentencesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(WKVocabulary_Sentence),
        .number = WKVocabulary_FieldNumber_SentencesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(WKVocabulary__storage_, sentencesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "partsOfSpeechArray",
        .dataTypeSpecific.enumDescFunc = WKVocabulary_PartOfSpeech_EnumDescriptor,
        .number = WKVocabulary_FieldNumber_PartsOfSpeechArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(WKVocabulary__storage_, partsOfSpeechArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "audio",
        .dataTypeSpecific.className = NULL,
        .number = WKVocabulary_FieldNumber_Audio,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WKVocabulary__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WKVocabulary class]
                                     rootClass:[WKWanikaniRoot class]
                                          file:WKWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WKVocabulary__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum WKVocabulary_PartOfSpeech

GPBEnumDescriptor *WKVocabulary_PartOfSpeech_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Noun\000Numeral\000IntransitiveVerb\000IchidanVer"
        "b\000TransitiveVerb\000NoAdjective\000GodanVerb\000N"
        "aAdjective\000IAdjective\000Suffix\000Adverb\000Suru"
        "Verb\000Prefix\000ProperNoun\000Expression\000Adject"
        "ive\000Interjection\000Counter\000Pronoun\000Conjunc"
        "tion\000";
    static const int32_t values[] = {
        WKVocabulary_PartOfSpeech_Noun,
        WKVocabulary_PartOfSpeech_Numeral,
        WKVocabulary_PartOfSpeech_IntransitiveVerb,
        WKVocabulary_PartOfSpeech_IchidanVerb,
        WKVocabulary_PartOfSpeech_TransitiveVerb,
        WKVocabulary_PartOfSpeech_NoAdjective,
        WKVocabulary_PartOfSpeech_GodanVerb,
        WKVocabulary_PartOfSpeech_NaAdjective,
        WKVocabulary_PartOfSpeech_IAdjective,
        WKVocabulary_PartOfSpeech_Suffix,
        WKVocabulary_PartOfSpeech_Adverb,
        WKVocabulary_PartOfSpeech_SuruVerb,
        WKVocabulary_PartOfSpeech_Prefix,
        WKVocabulary_PartOfSpeech_ProperNoun,
        WKVocabulary_PartOfSpeech_Expression,
        WKVocabulary_PartOfSpeech_Adjective,
        WKVocabulary_PartOfSpeech_Interjection,
        WKVocabulary_PartOfSpeech_Counter,
        WKVocabulary_PartOfSpeech_Pronoun,
        WKVocabulary_PartOfSpeech_Conjunction,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(WKVocabulary_PartOfSpeech)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:WKVocabulary_PartOfSpeech_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL WKVocabulary_PartOfSpeech_IsValidValue(int32_t value__) {
  switch (value__) {
    case WKVocabulary_PartOfSpeech_Noun:
    case WKVocabulary_PartOfSpeech_Numeral:
    case WKVocabulary_PartOfSpeech_IntransitiveVerb:
    case WKVocabulary_PartOfSpeech_IchidanVerb:
    case WKVocabulary_PartOfSpeech_TransitiveVerb:
    case WKVocabulary_PartOfSpeech_NoAdjective:
    case WKVocabulary_PartOfSpeech_GodanVerb:
    case WKVocabulary_PartOfSpeech_NaAdjective:
    case WKVocabulary_PartOfSpeech_IAdjective:
    case WKVocabulary_PartOfSpeech_Suffix:
    case WKVocabulary_PartOfSpeech_Adverb:
    case WKVocabulary_PartOfSpeech_SuruVerb:
    case WKVocabulary_PartOfSpeech_Prefix:
    case WKVocabulary_PartOfSpeech_ProperNoun:
    case WKVocabulary_PartOfSpeech_Expression:
    case WKVocabulary_PartOfSpeech_Adjective:
    case WKVocabulary_PartOfSpeech_Interjection:
    case WKVocabulary_PartOfSpeech_Counter:
    case WKVocabulary_PartOfSpeech_Pronoun:
    case WKVocabulary_PartOfSpeech_Conjunction:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - WKVocabulary_Sentence

@implementation WKVocabulary_Sentence

@dynamic hasJapanese, japanese;
@dynamic hasEnglish, english;

typedef struct WKVocabulary_Sentence__storage_ {
  uint32_t _has_storage_[1];
  NSString *japanese;
  NSString *english;
} WKVocabulary_Sentence__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "japanese",
        .dataTypeSpecific.className = NULL,
        .number = WKVocabulary_Sentence_FieldNumber_Japanese,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WKVocabulary_Sentence__storage_, japanese),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "english",
        .dataTypeSpecific.className = NULL,
        .number = WKVocabulary_Sentence_FieldNumber_English,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WKVocabulary_Sentence__storage_, english),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WKVocabulary_Sentence class]
                                     rootClass:[WKWanikaniRoot class]
                                          file:WKWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WKVocabulary_Sentence__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(WKVocabulary)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WKSubject

@implementation WKSubject

@dynamic hasId_p, id_p;
@dynamic hasLevel, level;
@dynamic hasSlug, slug;
@dynamic hasDocumentURL, documentURL;
@dynamic hasJapanese, japanese;
@dynamic readingsArray, readingsArray_Count;
@dynamic meaningsArray, meaningsArray_Count;
@dynamic componentSubjectIdsArray, componentSubjectIdsArray_Count;
@dynamic hasRadical, radical;
@dynamic hasKanji, kanji;
@dynamic hasVocabulary, vocabulary;

typedef struct WKSubject__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t level;
  NSString *slug;
  NSString *documentURL;
  NSString *japanese;
  NSMutableArray *readingsArray;
  NSMutableArray *meaningsArray;
  GPBInt32Array *componentSubjectIdsArray;
  WKRadical *radical;
  WKKanji *kanji;
  WKVocabulary *vocabulary;
} WKSubject__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = WKSubject_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WKSubject__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = WKSubject_FieldNumber_Level,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WKSubject__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "slug",
        .dataTypeSpecific.className = NULL,
        .number = WKSubject_FieldNumber_Slug,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WKSubject__storage_, slug),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "documentURL",
        .dataTypeSpecific.className = NULL,
        .number = WKSubject_FieldNumber_DocumentURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WKSubject__storage_, documentURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "japanese",
        .dataTypeSpecific.className = NULL,
        .number = WKSubject_FieldNumber_Japanese,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(WKSubject__storage_, japanese),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "readingsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(WKReading),
        .number = WKSubject_FieldNumber_ReadingsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(WKSubject__storage_, readingsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meaningsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(WKMeaning),
        .number = WKSubject_FieldNumber_MeaningsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(WKSubject__storage_, meaningsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "componentSubjectIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = WKSubject_FieldNumber_ComponentSubjectIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(WKSubject__storage_, componentSubjectIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "radical",
        .dataTypeSpecific.className = GPBStringifySymbol(WKRadical),
        .number = WKSubject_FieldNumber_Radical,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(WKSubject__storage_, radical),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "kanji",
        .dataTypeSpecific.className = GPBStringifySymbol(WKKanji),
        .number = WKSubject_FieldNumber_Kanji,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(WKSubject__storage_, kanji),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "vocabulary",
        .dataTypeSpecific.className = GPBStringifySymbol(WKVocabulary),
        .number = WKSubject_FieldNumber_Vocabulary,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(WKSubject__storage_, vocabulary),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WKSubject class]
                                     rootClass:[WKWanikaniRoot class]
                                          file:WKWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WKSubject__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\010\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum WKSubject_Type

GPBEnumDescriptor *WKSubject_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Radical\000Kanji\000Vocabulary\000";
    static const int32_t values[] = {
        WKSubject_Type_Radical,
        WKSubject_Type_Kanji,
        WKSubject_Type_Vocabulary,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(WKSubject_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:WKSubject_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL WKSubject_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case WKSubject_Type_Radical:
    case WKSubject_Type_Kanji:
    case WKSubject_Type_Vocabulary:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - WKAssignment

@implementation WKAssignment

@dynamic hasId_p, id_p;
@dynamic hasLevel, level;
@dynamic hasSubjectId, subjectId;
@dynamic hasSubjectType, subjectType;
@dynamic hasAvailableAt, availableAt;
@dynamic hasStartedAt, startedAt;
@dynamic hasSrsStage, srsStage;
@dynamic hasPassedAt, passedAt;

typedef struct WKAssignment__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t level;
  int32_t subjectId;
  WKSubject_Type subjectType;
  int32_t availableAt;
  int32_t startedAt;
  int32_t srsStage;
  int32_t passedAt;
} WKAssignment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "id_p",
        .core.dataTypeSpecific.className = NULL,
        .core.number = WKAssignment_FieldNumber_Id_p,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(WKAssignment__storage_, id_p),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "level",
        .core.dataTypeSpecific.className = NULL,
        .core.number = WKAssignment_FieldNumber_Level,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(WKAssignment__storage_, level),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "subjectId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = WKAssignment_FieldNumber_SubjectId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(WKAssignment__storage_, subjectId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueEnum = WKSubject_Type_Radical,
        .core.name = "subjectType",
        .core.dataTypeSpecific.enumDescFunc = WKSubject_Type_EnumDescriptor,
        .core.number = WKAssignment_FieldNumber_SubjectType,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(WKAssignment__storage_, subjectType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "availableAt",
        .core.dataTypeSpecific.className = NULL,
        .core.number = WKAssignment_FieldNumber_AvailableAt,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(WKAssignment__storage_, availableAt),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "startedAt",
        .core.dataTypeSpecific.className = NULL,
        .core.number = WKAssignment_FieldNumber_StartedAt,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(WKAssignment__storage_, startedAt),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "srsStage",
        .core.dataTypeSpecific.className = NULL,
        .core.number = WKAssignment_FieldNumber_SrsStage,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(WKAssignment__storage_, srsStage),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "passedAt",
        .core.dataTypeSpecific.className = NULL,
        .core.number = WKAssignment_FieldNumber_PassedAt,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(WKAssignment__storage_, passedAt),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WKAssignment class]
                                     rootClass:[WKWanikaniRoot class]
                                          file:WKWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(WKAssignment__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WKProgress

@implementation WKProgress

@dynamic hasSubjectId, subjectId;
@dynamic hasAssignmentId, assignmentId;
@dynamic hasMeaningWrong, meaningWrong;
@dynamic hasReadingWrong, readingWrong;

typedef struct WKProgress__storage_ {
  uint32_t _has_storage_[1];
  int32_t subjectId;
  int32_t assignmentId;
} WKProgress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "subjectId",
        .dataTypeSpecific.className = NULL,
        .number = WKProgress_FieldNumber_SubjectId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WKProgress__storage_, subjectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "assignmentId",
        .dataTypeSpecific.className = NULL,
        .number = WKProgress_FieldNumber_AssignmentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WKProgress__storage_, assignmentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "meaningWrong",
        .dataTypeSpecific.className = NULL,
        .number = WKProgress_FieldNumber_MeaningWrong,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "readingWrong",
        .dataTypeSpecific.className = NULL,
        .number = WKProgress_FieldNumber_ReadingWrong,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WKProgress class]
                                     rootClass:[WKWanikaniRoot class]
                                          file:WKWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WKProgress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WKStudyMaterials

@implementation WKStudyMaterials

@dynamic hasId_p, id_p;
@dynamic hasSubjectId, subjectId;
@dynamic hasSubjectType, subjectType;
@dynamic hasMeaningNote, meaningNote;
@dynamic hasReadingNote, readingNote;
@dynamic meaningSynonymsArray, meaningSynonymsArray_Count;

typedef struct WKStudyMaterials__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t subjectId;
  NSString *meaningNote;
  NSString *readingNote;
  NSMutableArray *meaningSynonymsArray;
  NSString *subjectType;
} WKStudyMaterials__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = WKStudyMaterials_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WKStudyMaterials__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subjectId",
        .dataTypeSpecific.className = NULL,
        .number = WKStudyMaterials_FieldNumber_SubjectId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WKStudyMaterials__storage_, subjectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "meaningNote",
        .dataTypeSpecific.className = NULL,
        .number = WKStudyMaterials_FieldNumber_MeaningNote,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WKStudyMaterials__storage_, meaningNote),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "readingNote",
        .dataTypeSpecific.className = NULL,
        .number = WKStudyMaterials_FieldNumber_ReadingNote,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(WKStudyMaterials__storage_, readingNote),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meaningSynonymsArray",
        .dataTypeSpecific.className = NULL,
        .number = WKStudyMaterials_FieldNumber_MeaningSynonymsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(WKStudyMaterials__storage_, meaningSynonymsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subjectType",
        .dataTypeSpecific.className = NULL,
        .number = WKStudyMaterials_FieldNumber_SubjectType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WKStudyMaterials__storage_, subjectType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WKStudyMaterials class]
                                     rootClass:[WKWanikaniRoot class]
                                          file:WKWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WKStudyMaterials__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WKUser

@implementation WKUser

@dynamic hasUsername, username;
@dynamic hasLevel, level;
@dynamic hasMaxLevelGrantedBySubscription, maxLevelGrantedBySubscription;
@dynamic hasProfileURL, profileURL;
@dynamic hasStartedAt, startedAt;
@dynamic hasSubscribed, subscribed;

typedef struct WKUser__storage_ {
  uint32_t _has_storage_[1];
  int32_t level;
  int32_t maxLevelGrantedBySubscription;
  int32_t startedAt;
  NSString *username;
  NSString *profileURL;
} WKUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = WKUser_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WKUser__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = WKUser_FieldNumber_Level,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WKUser__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxLevelGrantedBySubscription",
        .dataTypeSpecific.className = NULL,
        .number = WKUser_FieldNumber_MaxLevelGrantedBySubscription,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WKUser__storage_, maxLevelGrantedBySubscription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "profileURL",
        .dataTypeSpecific.className = NULL,
        .number = WKUser_FieldNumber_ProfileURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WKUser__storage_, profileURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startedAt",
        .dataTypeSpecific.className = NULL,
        .number = WKUser_FieldNumber_StartedAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(WKUser__storage_, startedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subscribed",
        .dataTypeSpecific.className = NULL,
        .number = WKUser_FieldNumber_Subscribed,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WKUser class]
                                     rootClass:[WKWanikaniRoot class]
                                          file:WKWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WKUser__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\007\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
