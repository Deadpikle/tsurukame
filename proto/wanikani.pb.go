// Code generated by protoc-gen-go. DO NOT EDIT.
// source: wanikani.proto

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	wanikani.proto

It has these top-level messages:
	Meaning
	Reading
	Radical
	Kanji
	Vocabulary
	Subject
	Assignment
	Progress
	StudyMaterials
	User
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

type Reading_Type int32

const (
	Reading_ONYOMI  Reading_Type = 1
	Reading_KUNYOMI Reading_Type = 2
	Reading_NANORI  Reading_Type = 3
)

var Reading_Type_name = map[int32]string{
	1: "ONYOMI",
	2: "KUNYOMI",
	3: "NANORI",
}
var Reading_Type_value = map[string]int32{
	"ONYOMI":  1,
	"KUNYOMI": 2,
	"NANORI":  3,
}

func (x Reading_Type) Enum() *Reading_Type {
	p := new(Reading_Type)
	*p = x
	return p
}
func (x Reading_Type) String() string {
	return proto1.EnumName(Reading_Type_name, int32(x))
}
func (x *Reading_Type) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(Reading_Type_value, data, "Reading_Type")
	if err != nil {
		return err
	}
	*x = Reading_Type(value)
	return nil
}
func (Reading_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type Vocabulary_PartOfSpeech int32

const (
	Vocabulary_NOUN              Vocabulary_PartOfSpeech = 1
	Vocabulary_NUMERAL           Vocabulary_PartOfSpeech = 2
	Vocabulary_INTRANSITIVE_VERB Vocabulary_PartOfSpeech = 3
	Vocabulary_ICHIDAN_VERB      Vocabulary_PartOfSpeech = 4
	Vocabulary_TRANSITIVE_VERB   Vocabulary_PartOfSpeech = 5
	Vocabulary_NO_ADJECTIVE      Vocabulary_PartOfSpeech = 6
	Vocabulary_GODAN_VERB        Vocabulary_PartOfSpeech = 7
	Vocabulary_NA_ADJECTIVE      Vocabulary_PartOfSpeech = 8
	Vocabulary_I_ADJECTIVE       Vocabulary_PartOfSpeech = 9
	Vocabulary_SUFFIX            Vocabulary_PartOfSpeech = 10
	Vocabulary_ADVERB            Vocabulary_PartOfSpeech = 11
	Vocabulary_SURU_VERB         Vocabulary_PartOfSpeech = 12
	Vocabulary_PREFIX            Vocabulary_PartOfSpeech = 13
	Vocabulary_PROPER_NOUN       Vocabulary_PartOfSpeech = 14
	Vocabulary_EXPRESSION        Vocabulary_PartOfSpeech = 15
	Vocabulary_ADJECTIVE         Vocabulary_PartOfSpeech = 16
	Vocabulary_INTERJECTION      Vocabulary_PartOfSpeech = 17
	Vocabulary_COUNTER           Vocabulary_PartOfSpeech = 18
	Vocabulary_PRONOUN           Vocabulary_PartOfSpeech = 19
	Vocabulary_CONJUNCTION       Vocabulary_PartOfSpeech = 20
)

var Vocabulary_PartOfSpeech_name = map[int32]string{
	1:  "NOUN",
	2:  "NUMERAL",
	3:  "INTRANSITIVE_VERB",
	4:  "ICHIDAN_VERB",
	5:  "TRANSITIVE_VERB",
	6:  "NO_ADJECTIVE",
	7:  "GODAN_VERB",
	8:  "NA_ADJECTIVE",
	9:  "I_ADJECTIVE",
	10: "SUFFIX",
	11: "ADVERB",
	12: "SURU_VERB",
	13: "PREFIX",
	14: "PROPER_NOUN",
	15: "EXPRESSION",
	16: "ADJECTIVE",
	17: "INTERJECTION",
	18: "COUNTER",
	19: "PRONOUN",
	20: "CONJUNCTION",
}
var Vocabulary_PartOfSpeech_value = map[string]int32{
	"NOUN":              1,
	"NUMERAL":           2,
	"INTRANSITIVE_VERB": 3,
	"ICHIDAN_VERB":      4,
	"TRANSITIVE_VERB":   5,
	"NO_ADJECTIVE":      6,
	"GODAN_VERB":        7,
	"NA_ADJECTIVE":      8,
	"I_ADJECTIVE":       9,
	"SUFFIX":            10,
	"ADVERB":            11,
	"SURU_VERB":         12,
	"PREFIX":            13,
	"PROPER_NOUN":       14,
	"EXPRESSION":        15,
	"ADJECTIVE":         16,
	"INTERJECTION":      17,
	"COUNTER":           18,
	"PRONOUN":           19,
	"CONJUNCTION":       20,
}

func (x Vocabulary_PartOfSpeech) Enum() *Vocabulary_PartOfSpeech {
	p := new(Vocabulary_PartOfSpeech)
	*p = x
	return p
}
func (x Vocabulary_PartOfSpeech) String() string {
	return proto1.EnumName(Vocabulary_PartOfSpeech_name, int32(x))
}
func (x *Vocabulary_PartOfSpeech) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(Vocabulary_PartOfSpeech_value, data, "Vocabulary_PartOfSpeech")
	if err != nil {
		return err
	}
	*x = Vocabulary_PartOfSpeech(value)
	return nil
}
func (Vocabulary_PartOfSpeech) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type Subject_Type int32

const (
	Subject_RADICAL    Subject_Type = 1
	Subject_KANJI      Subject_Type = 2
	Subject_VOCABULARY Subject_Type = 3
)

var Subject_Type_name = map[int32]string{
	1: "RADICAL",
	2: "KANJI",
	3: "VOCABULARY",
}
var Subject_Type_value = map[string]int32{
	"RADICAL":    1,
	"KANJI":      2,
	"VOCABULARY": 3,
}

func (x Subject_Type) Enum() *Subject_Type {
	p := new(Subject_Type)
	*p = x
	return p
}
func (x Subject_Type) String() string {
	return proto1.EnumName(Subject_Type_name, int32(x))
}
func (x *Subject_Type) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(Subject_Type_value, data, "Subject_Type")
	if err != nil {
		return err
	}
	*x = Subject_Type(value)
	return nil
}
func (Subject_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

type Meaning struct {
	Meaning          *string `protobuf:"bytes,1,opt,name=meaning" json:"meaning,omitempty"`
	IsPrimary        *bool   `protobuf:"varint,2,opt,name=is_primary,json=isPrimary" json:"is_primary,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Meaning) Reset()                    { *m = Meaning{} }
func (m *Meaning) String() string            { return proto1.CompactTextString(m) }
func (*Meaning) ProtoMessage()               {}
func (*Meaning) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Meaning) GetMeaning() string {
	if m != nil && m.Meaning != nil {
		return *m.Meaning
	}
	return ""
}

func (m *Meaning) GetIsPrimary() bool {
	if m != nil && m.IsPrimary != nil {
		return *m.IsPrimary
	}
	return false
}

type Reading struct {
	Reading          *string       `protobuf:"bytes,1,opt,name=reading" json:"reading,omitempty"`
	IsPrimary        *bool         `protobuf:"varint,2,opt,name=is_primary,json=isPrimary" json:"is_primary,omitempty"`
	Type             *Reading_Type `protobuf:"varint,3,opt,name=type,enum=proto.Reading_Type" json:"type,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Reading) Reset()                    { *m = Reading{} }
func (m *Reading) String() string            { return proto1.CompactTextString(m) }
func (*Reading) ProtoMessage()               {}
func (*Reading) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Reading) GetReading() string {
	if m != nil && m.Reading != nil {
		return *m.Reading
	}
	return ""
}

func (m *Reading) GetIsPrimary() bool {
	if m != nil && m.IsPrimary != nil {
		return *m.IsPrimary
	}
	return false
}

func (m *Reading) GetType() Reading_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Reading_ONYOMI
}

type Radical struct {
	CharacterImage        *string `protobuf:"bytes,1,opt,name=character_image,json=characterImage" json:"character_image,omitempty"`
	Mnemonic              *string `protobuf:"bytes,2,opt,name=mnemonic" json:"mnemonic,omitempty"`
	HasCharacterImageFile *bool   `protobuf:"varint,3,opt,name=has_character_image_file,json=hasCharacterImageFile" json:"has_character_image_file,omitempty"`
	XXX_unrecognized      []byte  `json:"-"`
}

func (m *Radical) Reset()                    { *m = Radical{} }
func (m *Radical) String() string            { return proto1.CompactTextString(m) }
func (*Radical) ProtoMessage()               {}
func (*Radical) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Radical) GetCharacterImage() string {
	if m != nil && m.CharacterImage != nil {
		return *m.CharacterImage
	}
	return ""
}

func (m *Radical) GetMnemonic() string {
	if m != nil && m.Mnemonic != nil {
		return *m.Mnemonic
	}
	return ""
}

func (m *Radical) GetHasCharacterImageFile() bool {
	if m != nil && m.HasCharacterImageFile != nil {
		return *m.HasCharacterImageFile
	}
	return false
}

type Kanji struct {
	MeaningMnemonic  *string `protobuf:"bytes,1,opt,name=meaning_mnemonic,json=meaningMnemonic" json:"meaning_mnemonic,omitempty"`
	MeaningHint      *string `protobuf:"bytes,2,opt,name=meaning_hint,json=meaningHint" json:"meaning_hint,omitempty"`
	ReadingMnemonic  *string `protobuf:"bytes,3,opt,name=reading_mnemonic,json=readingMnemonic" json:"reading_mnemonic,omitempty"`
	ReadingHint      *string `protobuf:"bytes,4,opt,name=reading_hint,json=readingHint" json:"reading_hint,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Kanji) Reset()                    { *m = Kanji{} }
func (m *Kanji) String() string            { return proto1.CompactTextString(m) }
func (*Kanji) ProtoMessage()               {}
func (*Kanji) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Kanji) GetMeaningMnemonic() string {
	if m != nil && m.MeaningMnemonic != nil {
		return *m.MeaningMnemonic
	}
	return ""
}

func (m *Kanji) GetMeaningHint() string {
	if m != nil && m.MeaningHint != nil {
		return *m.MeaningHint
	}
	return ""
}

func (m *Kanji) GetReadingMnemonic() string {
	if m != nil && m.ReadingMnemonic != nil {
		return *m.ReadingMnemonic
	}
	return ""
}

func (m *Kanji) GetReadingHint() string {
	if m != nil && m.ReadingHint != nil {
		return *m.ReadingHint
	}
	return ""
}

type Vocabulary struct {
	MeaningExplanation *string                   `protobuf:"bytes,1,opt,name=meaning_explanation,json=meaningExplanation" json:"meaning_explanation,omitempty"`
	ReadingExplanation *string                   `protobuf:"bytes,2,opt,name=reading_explanation,json=readingExplanation" json:"reading_explanation,omitempty"`
	Sentences          []*Vocabulary_Sentence    `protobuf:"bytes,3,rep,name=sentences" json:"sentences,omitempty"`
	PartsOfSpeech      []Vocabulary_PartOfSpeech `protobuf:"varint,4,rep,name=parts_of_speech,json=partsOfSpeech,enum=proto.Vocabulary_PartOfSpeech" json:"parts_of_speech,omitempty"`
	Audio              *string                   `protobuf:"bytes,5,opt,name=audio" json:"audio,omitempty"`
	XXX_unrecognized   []byte                    `json:"-"`
}

func (m *Vocabulary) Reset()                    { *m = Vocabulary{} }
func (m *Vocabulary) String() string            { return proto1.CompactTextString(m) }
func (*Vocabulary) ProtoMessage()               {}
func (*Vocabulary) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Vocabulary) GetMeaningExplanation() string {
	if m != nil && m.MeaningExplanation != nil {
		return *m.MeaningExplanation
	}
	return ""
}

func (m *Vocabulary) GetReadingExplanation() string {
	if m != nil && m.ReadingExplanation != nil {
		return *m.ReadingExplanation
	}
	return ""
}

func (m *Vocabulary) GetSentences() []*Vocabulary_Sentence {
	if m != nil {
		return m.Sentences
	}
	return nil
}

func (m *Vocabulary) GetPartsOfSpeech() []Vocabulary_PartOfSpeech {
	if m != nil {
		return m.PartsOfSpeech
	}
	return nil
}

func (m *Vocabulary) GetAudio() string {
	if m != nil && m.Audio != nil {
		return *m.Audio
	}
	return ""
}

type Vocabulary_Sentence struct {
	Japanese         *string `protobuf:"bytes,1,opt,name=japanese" json:"japanese,omitempty"`
	English          *string `protobuf:"bytes,2,opt,name=english" json:"english,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Vocabulary_Sentence) Reset()                    { *m = Vocabulary_Sentence{} }
func (m *Vocabulary_Sentence) String() string            { return proto1.CompactTextString(m) }
func (*Vocabulary_Sentence) ProtoMessage()               {}
func (*Vocabulary_Sentence) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

func (m *Vocabulary_Sentence) GetJapanese() string {
	if m != nil && m.Japanese != nil {
		return *m.Japanese
	}
	return ""
}

func (m *Vocabulary_Sentence) GetEnglish() string {
	if m != nil && m.English != nil {
		return *m.English
	}
	return ""
}

type Subject struct {
	Id                     *int32      `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Level                  *int32      `protobuf:"varint,2,opt,name=level" json:"level,omitempty"`
	Slug                   *string     `protobuf:"bytes,3,opt,name=slug" json:"slug,omitempty"`
	DocumentUrl            *string     `protobuf:"bytes,4,opt,name=document_url,json=documentUrl" json:"document_url,omitempty"`
	Japanese               *string     `protobuf:"bytes,5,opt,name=japanese" json:"japanese,omitempty"`
	Readings               []*Reading  `protobuf:"bytes,6,rep,name=readings" json:"readings,omitempty"`
	Meanings               []*Meaning  `protobuf:"bytes,7,rep,name=meanings" json:"meanings,omitempty"`
	ComponentSubjectIds    []int32     `protobuf:"varint,8,rep,name=component_subject_ids,json=componentSubjectIds" json:"component_subject_ids,omitempty"`
	AmalgamationSubjectIds []int32     `protobuf:"varint,12,rep,name=amalgamation_subject_ids,json=amalgamationSubjectIds" json:"amalgamation_subject_ids,omitempty"`
	Radical                *Radical    `protobuf:"bytes,9,opt,name=radical" json:"radical,omitempty"`
	Kanji                  *Kanji      `protobuf:"bytes,10,opt,name=kanji" json:"kanji,omitempty"`
	Vocabulary             *Vocabulary `protobuf:"bytes,11,opt,name=vocabulary" json:"vocabulary,omitempty"`
	XXX_unrecognized       []byte      `json:"-"`
}

func (m *Subject) Reset()                    { *m = Subject{} }
func (m *Subject) String() string            { return proto1.CompactTextString(m) }
func (*Subject) ProtoMessage()               {}
func (*Subject) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Subject) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Subject) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *Subject) GetSlug() string {
	if m != nil && m.Slug != nil {
		return *m.Slug
	}
	return ""
}

func (m *Subject) GetDocumentUrl() string {
	if m != nil && m.DocumentUrl != nil {
		return *m.DocumentUrl
	}
	return ""
}

func (m *Subject) GetJapanese() string {
	if m != nil && m.Japanese != nil {
		return *m.Japanese
	}
	return ""
}

func (m *Subject) GetReadings() []*Reading {
	if m != nil {
		return m.Readings
	}
	return nil
}

func (m *Subject) GetMeanings() []*Meaning {
	if m != nil {
		return m.Meanings
	}
	return nil
}

func (m *Subject) GetComponentSubjectIds() []int32 {
	if m != nil {
		return m.ComponentSubjectIds
	}
	return nil
}

func (m *Subject) GetAmalgamationSubjectIds() []int32 {
	if m != nil {
		return m.AmalgamationSubjectIds
	}
	return nil
}

func (m *Subject) GetRadical() *Radical {
	if m != nil {
		return m.Radical
	}
	return nil
}

func (m *Subject) GetKanji() *Kanji {
	if m != nil {
		return m.Kanji
	}
	return nil
}

func (m *Subject) GetVocabulary() *Vocabulary {
	if m != nil {
		return m.Vocabulary
	}
	return nil
}

type Assignment struct {
	Id               *int32        `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Level            *int32        `protobuf:"varint,2,opt,name=level" json:"level,omitempty"`
	SubjectId        *int32        `protobuf:"varint,3,opt,name=subject_id,json=subjectId" json:"subject_id,omitempty"`
	SubjectType      *Subject_Type `protobuf:"varint,4,opt,name=subject_type,json=subjectType,enum=proto.Subject_Type" json:"subject_type,omitempty"`
	AvailableAt      *int32        `protobuf:"varint,5,opt,name=available_at,json=availableAt" json:"available_at,omitempty"`
	StartedAt        *int32        `protobuf:"varint,6,opt,name=started_at,json=startedAt" json:"started_at,omitempty"`
	SrsStage         *int32        `protobuf:"varint,7,opt,name=srs_stage,json=srsStage" json:"srs_stage,omitempty"`
	PassedAt         *int32        `protobuf:"varint,8,opt,name=passed_at,json=passedAt" json:"passed_at,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Assignment) Reset()                    { *m = Assignment{} }
func (m *Assignment) String() string            { return proto1.CompactTextString(m) }
func (*Assignment) ProtoMessage()               {}
func (*Assignment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Assignment) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Assignment) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *Assignment) GetSubjectId() int32 {
	if m != nil && m.SubjectId != nil {
		return *m.SubjectId
	}
	return 0
}

func (m *Assignment) GetSubjectType() Subject_Type {
	if m != nil && m.SubjectType != nil {
		return *m.SubjectType
	}
	return Subject_RADICAL
}

func (m *Assignment) GetAvailableAt() int32 {
	if m != nil && m.AvailableAt != nil {
		return *m.AvailableAt
	}
	return 0
}

func (m *Assignment) GetStartedAt() int32 {
	if m != nil && m.StartedAt != nil {
		return *m.StartedAt
	}
	return 0
}

func (m *Assignment) GetSrsStage() int32 {
	if m != nil && m.SrsStage != nil {
		return *m.SrsStage
	}
	return 0
}

func (m *Assignment) GetPassedAt() int32 {
	if m != nil && m.PassedAt != nil {
		return *m.PassedAt
	}
	return 0
}

type Progress struct {
	MeaningWrong     *bool       `protobuf:"varint,3,opt,name=meaning_wrong,json=meaningWrong" json:"meaning_wrong,omitempty"`
	ReadingWrong     *bool       `protobuf:"varint,4,opt,name=reading_wrong,json=readingWrong" json:"reading_wrong,omitempty"`
	IsLesson         *bool       `protobuf:"varint,5,opt,name=is_lesson,json=isLesson" json:"is_lesson,omitempty"`
	Assignment       *Assignment `protobuf:"bytes,6,opt,name=assignment" json:"assignment,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Progress) Reset()                    { *m = Progress{} }
func (m *Progress) String() string            { return proto1.CompactTextString(m) }
func (*Progress) ProtoMessage()               {}
func (*Progress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Progress) GetMeaningWrong() bool {
	if m != nil && m.MeaningWrong != nil {
		return *m.MeaningWrong
	}
	return false
}

func (m *Progress) GetReadingWrong() bool {
	if m != nil && m.ReadingWrong != nil {
		return *m.ReadingWrong
	}
	return false
}

func (m *Progress) GetIsLesson() bool {
	if m != nil && m.IsLesson != nil {
		return *m.IsLesson
	}
	return false
}

func (m *Progress) GetAssignment() *Assignment {
	if m != nil {
		return m.Assignment
	}
	return nil
}

type StudyMaterials struct {
	Id               *int32   `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	SubjectId        *int32   `protobuf:"varint,2,opt,name=subject_id,json=subjectId" json:"subject_id,omitempty"`
	SubjectType      *string  `protobuf:"bytes,6,opt,name=subject_type,json=subjectType" json:"subject_type,omitempty"`
	MeaningNote      *string  `protobuf:"bytes,3,opt,name=meaning_note,json=meaningNote" json:"meaning_note,omitempty"`
	ReadingNote      *string  `protobuf:"bytes,4,opt,name=reading_note,json=readingNote" json:"reading_note,omitempty"`
	MeaningSynonyms  []string `protobuf:"bytes,5,rep,name=meaning_synonyms,json=meaningSynonyms" json:"meaning_synonyms,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *StudyMaterials) Reset()                    { *m = StudyMaterials{} }
func (m *StudyMaterials) String() string            { return proto1.CompactTextString(m) }
func (*StudyMaterials) ProtoMessage()               {}
func (*StudyMaterials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *StudyMaterials) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *StudyMaterials) GetSubjectId() int32 {
	if m != nil && m.SubjectId != nil {
		return *m.SubjectId
	}
	return 0
}

func (m *StudyMaterials) GetSubjectType() string {
	if m != nil && m.SubjectType != nil {
		return *m.SubjectType
	}
	return ""
}

func (m *StudyMaterials) GetMeaningNote() string {
	if m != nil && m.MeaningNote != nil {
		return *m.MeaningNote
	}
	return ""
}

func (m *StudyMaterials) GetReadingNote() string {
	if m != nil && m.ReadingNote != nil {
		return *m.ReadingNote
	}
	return ""
}

func (m *StudyMaterials) GetMeaningSynonyms() []string {
	if m != nil {
		return m.MeaningSynonyms
	}
	return nil
}

type User struct {
	Username                      *string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	Level                         *int32  `protobuf:"varint,2,opt,name=level" json:"level,omitempty"`
	MaxLevelGrantedBySubscription *int32  `protobuf:"varint,3,opt,name=max_level_granted_by_subscription,json=maxLevelGrantedBySubscription" json:"max_level_granted_by_subscription,omitempty"`
	ProfileUrl                    *string `protobuf:"bytes,4,opt,name=profile_url,json=profileUrl" json:"profile_url,omitempty"`
	StartedAt                     *int32  `protobuf:"varint,5,opt,name=started_at,json=startedAt" json:"started_at,omitempty"`
	Subscribed                    *bool   `protobuf:"varint,6,opt,name=subscribed" json:"subscribed,omitempty"`
	XXX_unrecognized              []byte  `json:"-"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto1.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *User) GetUsername() string {
	if m != nil && m.Username != nil {
		return *m.Username
	}
	return ""
}

func (m *User) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *User) GetMaxLevelGrantedBySubscription() int32 {
	if m != nil && m.MaxLevelGrantedBySubscription != nil {
		return *m.MaxLevelGrantedBySubscription
	}
	return 0
}

func (m *User) GetProfileUrl() string {
	if m != nil && m.ProfileUrl != nil {
		return *m.ProfileUrl
	}
	return ""
}

func (m *User) GetStartedAt() int32 {
	if m != nil && m.StartedAt != nil {
		return *m.StartedAt
	}
	return 0
}

func (m *User) GetSubscribed() bool {
	if m != nil && m.Subscribed != nil {
		return *m.Subscribed
	}
	return false
}

func init() {
	proto1.RegisterType((*Meaning)(nil), "proto.Meaning")
	proto1.RegisterType((*Reading)(nil), "proto.Reading")
	proto1.RegisterType((*Radical)(nil), "proto.Radical")
	proto1.RegisterType((*Kanji)(nil), "proto.Kanji")
	proto1.RegisterType((*Vocabulary)(nil), "proto.Vocabulary")
	proto1.RegisterType((*Vocabulary_Sentence)(nil), "proto.Vocabulary.Sentence")
	proto1.RegisterType((*Subject)(nil), "proto.Subject")
	proto1.RegisterType((*Assignment)(nil), "proto.Assignment")
	proto1.RegisterType((*Progress)(nil), "proto.Progress")
	proto1.RegisterType((*StudyMaterials)(nil), "proto.StudyMaterials")
	proto1.RegisterType((*User)(nil), "proto.User")
	proto1.RegisterEnum("proto.Reading_Type", Reading_Type_name, Reading_Type_value)
	proto1.RegisterEnum("proto.Vocabulary_PartOfSpeech", Vocabulary_PartOfSpeech_name, Vocabulary_PartOfSpeech_value)
	proto1.RegisterEnum("proto.Subject_Type", Subject_Type_name, Subject_Type_value)
}

func init() { proto1.RegisterFile("wanikani.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1251 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x06, 0x25, 0xd1, 0xa2, 0x46, 0xb2, 0xcc, 0xac, 0x93, 0x82, 0x48, 0x90, 0x54, 0x66, 0x0f,
	0x71, 0x5b, 0xc0, 0x45, 0x7d, 0x68, 0x73, 0x2c, 0x2d, 0xcb, 0x09, 0xfd, 0x43, 0x0a, 0x2b, 0xcb,
	0x49, 0x4e, 0xc4, 0x5a, 0xda, 0xc8, 0x9b, 0xf0, 0x47, 0xe0, 0x52, 0x49, 0xf4, 0x00, 0x45, 0x1f,
	0xa0, 0x97, 0x9e, 0xdb, 0x17, 0xe8, 0x63, 0xf4, 0xde, 0x37, 0xe8, 0x5b, 0xf4, 0x56, 0xec, 0x0f,
	0x25, 0x4a, 0x41, 0xd1, 0x9e, 0xc4, 0xf9, 0xe6, 0x9b, 0xd9, 0xd9, 0x99, 0xd9, 0x19, 0x41, 0xf7,
	0x03, 0x49, 0xd9, 0x3b, 0x92, 0xb2, 0xa3, 0x79, 0x9e, 0x15, 0x19, 0x32, 0xe5, 0x8f, 0x7b, 0x02,
	0xcd, 0x2b, 0x4a, 0x52, 0x96, 0xce, 0x90, 0x03, 0xcd, 0x44, 0x7d, 0x3a, 0x46, 0xcf, 0x38, 0x6c,
	0xe1, 0x52, 0x44, 0x8f, 0x01, 0x18, 0x8f, 0xe6, 0x39, 0x4b, 0x48, 0xbe, 0x74, 0x6a, 0x3d, 0xe3,
	0xd0, 0xc2, 0x2d, 0xc6, 0x87, 0x0a, 0x70, 0x7f, 0x31, 0xa0, 0x89, 0x29, 0x99, 0x6a, 0x27, 0xb9,
	0xfa, 0x2c, 0x9d, 0x68, 0xf1, 0x3f, 0x9c, 0xa0, 0xa7, 0xd0, 0x28, 0x96, 0x73, 0xea, 0xd4, 0x7b,
	0xc6, 0x61, 0xf7, 0x78, 0x5f, 0x45, 0x79, 0xa4, 0xdd, 0x1e, 0x5d, 0x2f, 0xe7, 0x14, 0x4b, 0x82,
	0xfb, 0x35, 0x34, 0x84, 0x84, 0x00, 0x76, 0xc2, 0xe0, 0x75, 0x78, 0xe5, 0xdb, 0x06, 0x6a, 0x43,
	0xf3, 0x62, 0xac, 0x84, 0x9a, 0x50, 0x04, 0x5e, 0x10, 0x62, 0xdf, 0xae, 0xbb, 0x3f, 0x89, 0xd0,
	0xc8, 0x94, 0x4d, 0x48, 0x8c, 0x9e, 0xc2, 0xde, 0xe4, 0x8e, 0xe4, 0x64, 0x52, 0xd0, 0x3c, 0x62,
	0x09, 0x99, 0x51, 0x1d, 0x62, 0x77, 0x05, 0xfb, 0x02, 0x45, 0x0f, 0xc1, 0x4a, 0x52, 0x9a, 0x64,
	0x29, 0x9b, 0xc8, 0x38, 0x5b, 0x78, 0x25, 0xa3, 0xef, 0xc1, 0xb9, 0x23, 0x3c, 0xda, 0x72, 0x14,
	0xbd, 0x61, 0xb1, 0x0a, 0xdd, 0xc2, 0x0f, 0xee, 0x08, 0xef, 0x6f, 0x38, 0x3c, 0x63, 0x31, 0x75,
	0x7f, 0x33, 0xc0, 0xbc, 0x20, 0xe9, 0x5b, 0x86, 0xbe, 0x04, 0x5b, 0x27, 0x36, 0x5a, 0x1d, 0xa3,
	0x02, 0xd9, 0xd3, 0xf8, 0x55, 0x79, 0xda, 0x01, 0x74, 0x4a, 0xea, 0x1d, 0x4b, 0x0b, 0x1d, 0x4d,
	0x5b, 0x63, 0x2f, 0x58, 0x5a, 0x08, 0x6f, 0x3a, 0xc3, 0x6b, 0x6f, 0x75, 0xe5, 0x4d, 0xe3, 0x55,
	0x6f, 0x25, 0x55, 0x7a, 0x6b, 0x28, 0x6f, 0x1a, 0x13, 0xde, 0xdc, 0x9f, 0x4d, 0x80, 0x9b, 0x6c,
	0x42, 0x6e, 0x17, 0xb1, 0x28, 0xca, 0x37, 0xb0, 0x5f, 0x9e, 0x4f, 0x3f, 0xce, 0x63, 0x92, 0x92,
	0x82, 0x65, 0xa9, 0x8e, 0x16, 0x69, 0xd5, 0x60, 0xad, 0x11, 0x06, 0xe5, 0x11, 0x55, 0x03, 0x15,
	0x37, 0xd2, 0xaa, 0xaa, 0xc1, 0x33, 0x68, 0x71, 0x9a, 0x16, 0x34, 0x9d, 0x50, 0xee, 0xd4, 0x7b,
	0xf5, 0xc3, 0xf6, 0xf1, 0x43, 0x5d, 0xfb, 0x75, 0x1c, 0x47, 0x23, 0x4d, 0xc1, 0x6b, 0x32, 0x3a,
	0x83, 0xbd, 0x39, 0xc9, 0x0b, 0x1e, 0x65, 0x6f, 0x22, 0x3e, 0xa7, 0x74, 0x72, 0xe7, 0x34, 0x7a,
	0xf5, 0xc3, 0xee, 0xf1, 0x93, 0x4f, 0xed, 0x87, 0x24, 0x2f, 0xc2, 0x37, 0x23, 0xc9, 0xc2, 0xbb,
	0xd2, 0xac, 0x14, 0xd1, 0x7d, 0x30, 0xc9, 0x62, 0xca, 0x32, 0xc7, 0x94, 0x41, 0x2a, 0xe1, 0xe1,
	0x0f, 0x60, 0x95, 0x87, 0x8a, 0x7e, 0x78, 0x4b, 0xe6, 0x24, 0xa5, 0xbc, 0xec, 0x98, 0x95, 0x2c,
	0xfa, 0x9d, 0xa6, 0xb3, 0x98, 0xf1, 0x3b, 0x7d, 0xc9, 0x52, 0x74, 0xff, 0xa8, 0x41, 0xa7, 0x7a,
	0x2e, 0xb2, 0xa0, 0x11, 0x84, 0xe3, 0x40, 0xb5, 0x6b, 0x30, 0xbe, 0x1a, 0x60, 0xef, 0xd2, 0xae,
	0xa1, 0x07, 0x70, 0xcf, 0x0f, 0xae, 0xb1, 0x17, 0x8c, 0xfc, 0x6b, 0xff, 0x66, 0x10, 0xdd, 0x0c,
	0xf0, 0x89, 0x5d, 0x47, 0x36, 0x74, 0xfc, 0xfe, 0x0b, 0xff, 0xd4, 0x0b, 0x14, 0xd2, 0x40, 0xfb,
	0xb0, 0xb7, 0x4d, 0x33, 0x05, 0x2d, 0x08, 0x23, 0xef, 0xf4, 0x7c, 0xd0, 0x17, 0xb0, 0xbd, 0x83,
	0xba, 0x00, 0xcf, 0xc3, 0x95, 0x59, 0x53, 0x32, 0xbc, 0x0a, 0xc3, 0x42, 0x7b, 0xd0, 0xf6, 0x2b,
	0x40, 0x4b, 0xbc, 0x98, 0xd1, 0xf8, 0xec, 0xcc, 0x7f, 0x65, 0x83, 0xf8, 0xf6, 0x4e, 0xa5, 0x69,
	0x1b, 0xed, 0x42, 0x6b, 0x34, 0xc6, 0x63, 0xe5, 0xa9, 0x23, 0x54, 0x43, 0x3c, 0x10, 0xb4, 0x5d,
	0xe1, 0x63, 0x88, 0xc3, 0xe1, 0x00, 0x47, 0xf2, 0x4e, 0x5d, 0x71, 0xec, 0xe0, 0xd5, 0x10, 0x0f,
	0x46, 0x23, 0x3f, 0x0c, 0xec, 0x3d, 0x61, 0xbb, 0x3e, 0xc2, 0x96, 0xd7, 0x09, 0xae, 0x07, 0x58,
	0x22, 0x61, 0x60, 0xdf, 0x13, 0x49, 0xe8, 0x87, 0x63, 0x81, 0xd9, 0x48, 0x08, 0x43, 0x1c, 0x4a,
	0x57, 0xfb, 0xc2, 0x77, 0x3f, 0x0c, 0xce, 0xc7, 0x81, 0xa2, 0xde, 0x77, 0xff, 0xae, 0x43, 0x73,
	0xb4, 0xb8, 0x7d, 0x4b, 0x27, 0x05, 0xea, 0x42, 0x8d, 0x4d, 0x65, 0x19, 0x4c, 0x5c, 0x63, 0x53,
	0x51, 0xbe, 0x98, 0xbe, 0xa7, 0xb1, 0x4c, 0xbf, 0x89, 0x95, 0x80, 0x10, 0x34, 0x78, 0xbc, 0x98,
	0xe9, 0x97, 0x20, 0xbf, 0x45, 0xfb, 0x4f, 0xb3, 0xc9, 0x22, 0xa1, 0x69, 0x11, 0x2d, 0xf2, 0xb8,
	0x6c, 0xff, 0x12, 0x1b, 0xe7, 0xf1, 0x46, 0xa5, 0xcd, 0xad, 0x4a, 0x7f, 0x05, 0x96, 0xee, 0x5f,
	0xee, 0xec, 0xc8, 0x46, 0xed, 0x6e, 0x0e, 0x29, 0xbc, 0xd2, 0x0b, 0xae, 0x7e, 0x1c, 0xdc, 0x69,
	0x6e, 0x70, 0xf5, 0xb0, 0xc5, 0x2b, 0x3d, 0x3a, 0x86, 0x07, 0x93, 0x2c, 0x99, 0x67, 0xa9, 0x88,
	0x8b, 0xab, 0x5b, 0x46, 0x6c, 0xca, 0x1d, 0xab, 0x57, 0x3f, 0x34, 0xf1, 0xfe, 0x4a, 0xa9, 0x33,
	0xe0, 0x4f, 0x39, 0x7a, 0x06, 0x0e, 0x49, 0x48, 0x3c, 0x23, 0x89, 0x7c, 0x45, 0x1b, 0x66, 0x1d,
	0x69, 0xf6, 0x59, 0x55, 0x5f, 0xb1, 0x3c, 0x84, 0x66, 0xae, 0xe6, 0xa1, 0xd3, 0xea, 0x19, 0xd5,
	0x4b, 0x28, 0x14, 0x97, 0x6a, 0xe4, 0x82, 0xf9, 0x4e, 0xcc, 0x2b, 0x07, 0x24, 0xaf, 0xa3, 0x79,
	0x72, 0x86, 0x61, 0xa5, 0x42, 0xdf, 0x02, 0xbc, 0x5f, 0xbd, 0x32, 0xa7, 0x2d, 0x89, 0xf7, 0x3e,
	0x79, 0x7e, 0xb8, 0x42, 0x72, 0x8f, 0xf4, 0xf8, 0x6e, 0x43, 0x13, 0x7b, 0xa7, 0x7e, 0xdf, 0xbb,
	0xb4, 0x0d, 0xd4, 0x02, 0xf3, 0xc2, 0x0b, 0xce, 0xc5, 0xf4, 0xee, 0x02, 0xdc, 0x84, 0x7d, 0xef,
	0x64, 0x7c, 0xe9, 0xe1, 0xd7, 0x76, 0xdd, 0xfd, 0xb1, 0x06, 0xe0, 0x71, 0xce, 0x66, 0xa9, 0x28,
	0xd2, 0xff, 0x2c, 0xff, 0x63, 0x80, 0x75, 0x4a, 0x64, 0x13, 0x98, 0xb8, 0xc5, 0xcb, 0x2c, 0xa0,
	0xef, 0xa0, 0x53, 0xaa, 0xe5, 0xce, 0x69, 0x6c, 0xec, 0x1c, 0x9d, 0x2d, 0xb5, 0x73, 0xda, 0x9a,
	0x28, 0x63, 0x3e, 0x80, 0x0e, 0x79, 0x4f, 0x58, 0x4c, 0x6e, 0x63, 0x1a, 0x91, 0x42, 0xb6, 0x88,
	0x89, 0xdb, 0x2b, 0xcc, 0x2b, 0xe4, 0xc9, 0x05, 0xc9, 0x0b, 0x3a, 0x15, 0x84, 0x1d, 0x7d, 0xb2,
	0x42, 0xbc, 0x02, 0x3d, 0x82, 0x16, 0xcf, 0x79, 0xc4, 0x0b, 0xb1, 0x7d, 0x9a, 0x52, 0x6b, 0xf1,
	0x9c, 0x8f, 0x84, 0x2c, 0x94, 0x73, 0xc2, 0xb9, 0x32, 0xb5, 0x94, 0x52, 0x01, 0x5e, 0xe1, 0xfe,
	0x6e, 0x80, 0x35, 0xcc, 0xb3, 0x59, 0x4e, 0x39, 0x47, 0x5f, 0xc0, 0x6e, 0x39, 0x97, 0x3f, 0xe4,
	0x59, 0x3a, 0xd3, 0xab, 0xa7, 0x5c, 0x16, 0x2f, 0x05, 0x26, 0x48, 0xe5, 0x2c, 0x56, 0xa4, 0x86,
	0x22, 0x69, 0x50, 0x91, 0x1e, 0x41, 0x8b, 0xf1, 0x28, 0xa6, 0x9c, 0x67, 0xa9, 0xbc, 0x8f, 0x85,
	0x2d, 0xc6, 0x2f, 0xa5, 0x2c, 0xca, 0x4b, 0x56, 0xa9, 0x97, 0x97, 0x59, 0x97, 0x77, 0x5d, 0x13,
	0x5c, 0x21, 0x9d, 0x37, 0x2c, 0xc3, 0xae, 0x9d, 0x37, 0xac, 0x9a, 0x5d, 0x77, 0xff, 0x34, 0xa0,
	0x3b, 0x2a, 0x16, 0xd3, 0xe5, 0x15, 0x29, 0x68, 0xce, 0x48, 0xcc, 0x3f, 0x29, 0xdf, 0x66, 0xa1,
	0x6a, 0xdb, 0x85, 0x3a, 0xd8, 0x2a, 0xd4, 0x8e, 0x7a, 0xb2, 0x5b, 0x35, 0x29, 0x53, 0x91, 0x66,
	0x05, 0xd5, 0x2f, 0xbe, 0x5c, 0x91, 0x41, 0x56, 0xd0, 0xea, 0xde, 0x93, 0x94, 0xcd, 0xbd, 0x27,
	0x29, 0x95, 0x9d, 0xcc, 0x97, 0x69, 0x96, 0x2e, 0x13, 0xee, 0x98, 0xbd, 0x7a, 0x65, 0x27, 0x8f,
	0x34, 0xec, 0xfe, 0x65, 0x40, 0x63, 0xcc, 0x69, 0x2e, 0x86, 0xc5, 0x82, 0xd3, 0x3c, 0x25, 0xc9,
	0x6a, 0x2d, 0x94, 0xf2, 0xbf, 0xb4, 0xe5, 0x0b, 0x38, 0x48, 0xc8, 0xc7, 0x48, 0x0a, 0xd1, 0x2c,
	0x27, 0xa9, 0x68, 0x93, 0xdb, 0xa5, 0x78, 0xbe, 0x7c, 0x92, 0xb3, 0xb9, 0xdc, 0x95, 0xaa, 0x5b,
	0x1f, 0x27, 0xe4, 0xe3, 0xa5, 0xe0, 0x3d, 0x57, 0xb4, 0x93, 0xe5, 0xa8, 0x42, 0x42, 0x9f, 0x43,
	0x7b, 0x9e, 0x67, 0xe2, 0x5f, 0x47, 0x65, 0x94, 0x81, 0x86, 0xc4, 0x24, 0xdb, 0xec, 0x43, 0x73,
	0xbb, 0x0f, 0x9f, 0xc8, 0xbc, 0x0b, 0x7f, 0xb7, 0x74, 0x2a, 0xd3, 0x6a, 0xe1, 0x0a, 0x72, 0x62,
	0xfe, 0x5a, 0xab, 0xbd, 0xbc, 0xf8, 0x27, 0x00, 0x00, 0xff, 0xff, 0x2b, 0x6b, 0xaf, 0x30, 0x35,
	0x0a, 0x00, 0x00,
}
